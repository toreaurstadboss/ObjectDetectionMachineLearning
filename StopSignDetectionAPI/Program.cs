// This file was auto-generated by ML.NET Model Builder. 
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.ML;
using Microsoft.OpenApi.Models;
using Microsoft.ML.Data;
using System.Drawing;
using System.IO;
using System.Threading.Tasks;
using StopSignDetection_WebApi1;
using Microsoft.AspNetCore.Mvc;

// Configure app
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddPredictionEnginePool<StopSignDetection.ModelInput, StopSignDetection.ModelOutput>()
    .FromFile("StopSignDetection.mlnet");

builder.Services.AddEndpointsApiExplorer();

builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo { Title = "Object detection - Stop sign detection", Description = "Docs for my API", Version = "v1" });
});
var app = builder.Build();

app.UseSwagger();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI(c =>
    {
        c.SwaggerEndpoint("/swagger/v1/swagger.json", "Object detection - Machine learning MLN.");
    });
}


// Define prediction route & handler
app.MapPost("/predict",
    async (HttpContext context, PredictionEnginePool<StopSignDetection.ModelInput, StopSignDetection.ModelOutput> predictionEnginePool, [FromBody] PredictRequest request) =>
    {
        // Disable caching
        context.Response.Headers["Cache-Control"] = "no-store, no-cache, must-revalidate, max-age=0";
        context.Response.Headers["Pragma"] = "no-cache";
        context.Response.Headers["Expires"] = "0";

        var image = MLImage.CreateFromFile(request.ImagePath);

        var input = new StopSignDetection.ModelInput()
        {
            Image = image,
        };


        // Get original image dimensions
        int originalWidth = image.Width;
        int originalHeight = image.Height;

        const int virtualWidth = 800;
        const int virtualHeight = 600;

        var prediction = predictionEnginePool.Predict(input);
        var boxes = prediction.PredictedBoundingBoxes;

        for (int i = 0; i < boxes.Length; i += 4)
        {
            float left = boxes[i];
            float top = boxes[i + 1];
            float width = boxes[i + 2];
            float height = boxes[i + 3];

            // Scale to original image size
            float scaledLeft = left * originalWidth / virtualWidth;
            float scaledTop = top * originalHeight / virtualHeight;
            float scaledWidth = width * originalWidth / virtualWidth;
            float scaledHeight = height * originalHeight / virtualHeight;

            Console.WriteLine($"Box {i / 4}: X={scaledLeft}, Y={scaledTop}, Width={scaledWidth}, Height={scaledHeight}");

            (boxes[i], boxes[i + 1], boxes[i + 2], boxes[i + 3]) = (scaledLeft, scaledTop, scaledWidth, scaledHeight);  
        }

        return await Task.FromResult(prediction);
    });

// Run app
app.Run();
